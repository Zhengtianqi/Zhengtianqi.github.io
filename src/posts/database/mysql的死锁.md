---
title: mysql的死锁
author: ztq
tag:
  - mysql
category:
  - 数据库
date: 2024-12-06 16:43:00
---
### 1. **死锁的概念**

**死锁**是指两个或多个事务互相等待对方释放资源，导致所有事务都无法继续执行的情况。每个事务都在等待其他事务持有的锁，形成一个循环依赖，从而导致系统无法继续前进。

### 2. **死锁的原因**

死锁通常发生在并发事务之间争夺资源时，特别是在以下情况下：

- **多个事务以不同的顺序锁定相同的资源**：例如，事务A先锁定了表T1，然后尝试锁定表T2；而事务B先锁定了表T2，然后尝试锁定表T1。如果两个事务同时进行，可能会形成死锁。

- **长时间持有锁**：如果一个事务长时间持有锁而不释放，可能会导致其他事务等待过久，增加死锁的可能性。

- **嵌套锁**：当一个事务在一个事务内部又启动了另一个事务（嵌套事务），并且这两个事务都持有了不同的锁，可能会导致死锁。

- **索引覆盖不全**：如果查询没有使用合适的索引，可能会导致更多的行被锁定，增加了死锁的风险。

- **隐式锁**：某些操作（如`SELECT ... FOR UPDATE`）会隐式地获取行级锁，如果没有正确管理这些锁，可能会引发死锁。

### 3. **死锁的检测**

mysql的InnoDB存储引擎内置了死锁检测机制。当检测到死锁时，InnoDB会选择一个事务作为“牺牲者”（victim），并回滚该事务，以解除死锁。具体过程如下：

- **死锁检测算法**：InnoDB使用一种称为“等待图”的算法来检测死锁。每个事务在等待某个资源时，都会在等待图中创建一条边。如果等待图中形成了一个环，说明存在死锁。

- **选择牺牲者**：InnoDB会选择一个代价最小的事务作为牺牲者。通常，选择的是已经做了最少工作的事务，以减少回滚的成本。

- **回滚牺牲者**：被选为牺牲者的事务会被强制回滚，释放其持有的所有锁，从而解除死锁。

- **返回错误**：mysql会返回一个错误码 `1213 (ER_LOCK_DEADLOCK)`，表示发生了死锁。应用程序需要捕获这个错误并进行适当的处理。

### 4. **死锁的预防**

虽然mysql可以自动检测并解决死锁，但频繁的死锁会影响系统的性能和用户体验。因此，预防死锁是非常重要的。以下是一些常见的预防措施：

#### **4.1. 统一锁的顺序**
- **按固定顺序加锁**：确保所有事务以相同的顺序获取锁。例如，如果多个事务都需要锁定表T1和T2，确保它们总是先锁定T1，再锁定T2。这样可以避免循环依赖，减少死锁的发生。

#### **4.2. 尽量缩短事务的生命周期**
- **尽早提交事务**：尽量减少事务的持续时间，尽早提交或回滚事务。长时间持有锁会增加死锁的可能性。
- **批量操作**：如果需要对大量数据进行更新，考虑分批处理，而不是一次性锁定大量行。

#### **4.3. 使用合适的数据隔离级别**
- **选择合适的隔离级别**：mysql支持四种隔离级别：读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。默认情况下，InnoDB使用的是`可重复读`级别。较高的隔离级别（如`串行化`）会增加锁的竞争，容易引发死锁，因此应根据实际需求选择合适的隔离级别。

#### **4.4. 避免不必要的锁**
- **只锁定必要的行**：尽量避免使用`SELECT ... FOR UPDATE`或`SELECT ... LOCK IN SHARE MODE`锁定过多的行。如果只需要锁定特定的几行，确保查询条件足够精确。
- **使用非锁定查询**：对于不需要修改数据的查询，尽量使用`READ COMMITTED`隔离级别或`NOLOCK`提示（在某些SQL方言中），以减少锁的使用。

#### **4.5. 优化索引**
- **确保查询使用索引**：良好的索引设计可以减少锁定的行数，降低死锁的可能性。特别是对于`UPDATE`、`DELETE`等修改操作，确保查询能够快速定位到目标行，避免全表扫描。

#### **4.6. 避免嵌套事务**
- **简化事务逻辑**：尽量避免在事务内部启动新的事务，尤其是在多层嵌套的情况下。嵌套事务会增加锁的复杂性，容易引发死锁。

#### **4.7. 使用乐观锁**
- **乐观锁**：对于一些竞争不激烈的场景，可以考虑使用乐观锁（Optimistic Locking）。乐观锁不会立即加锁，而是在提交时检查是否有冲突。如果有冲突，则重试操作。这种方式可以减少锁的竞争，降低死锁的可能性。

### 5. **处理死锁**

即使采取了预防措施，死锁仍然可能发生。因此，应用程序需要具备处理死锁的能力。常见的处理方式包括：

- **捕获死锁错误**：在代码中捕获 `ER_LOCK_DEADLOCK` 错误（错误码1213），并进行适当的处理。通常的做法是重试失败的事务，或者记录日志并通知管理员。

- **重试机制**：对于可以重试的操作，可以在捕获死锁错误后，等待一段时间（如几百毫秒），然后重新执行事务。注意设置合理的重试次数，避免无限重试。

- **日志记录**：记录死锁发生的时间、涉及的事务ID、锁定的资源等信息，方便后续分析和优化。

- **监控和报警**：通过监控工具（如Prometheus、Grafana）实时监控死锁的发生频率，并设置报警阈值。一旦死锁频繁发生，及时采取措施进行优化。

### 6. **常见问题及思路**

#### **Q1: 什么是死锁？**
- **回答思路**：死锁是指两个或多个事务互相等待对方释放资源，导致所有事务都无法继续执行的情况。mysql的InnoDB存储引擎会自动检测死锁，并选择一个事务作为牺牲者进行回滚。

#### **Q2: mysql如何检测死锁？**
- **回答思路**：mysql的InnoDB存储引擎使用“等待图”算法来检测死锁。当检测到等待图中形成环时，说明存在死锁。InnoDB会选择一个代价最小的事务作为牺牲者，并回滚该事务。

#### **Q3: 如何预防死锁？**
- **回答思路**：可以通过统一锁的顺序、缩短事务的生命周期、使用合适的隔离级别、避免不必要的锁、优化索引等方式来预防死锁。此外，还可以使用乐观锁来减少锁的竞争。

#### **Q4: 发生死锁时，mysql会怎么做？**
- **回答思路**：当发生死锁时，mysql的InnoDB存储引擎会选择一个代价最小的事务作为牺牲者，并回滚该事务。应用程序需要捕获 `ER_LOCK_DEADLOCK` 错误，并进行适当的处理，如重试事务或记录日志。

#### **Q5: 如何处理死锁？**
- **回答思路**：可以在代码中捕获死锁错误，并实现重试机制。对于可以重试的操作，可以在捕获死锁错误后，等待一段时间，然后重新执行事务。同时，记录死锁发生的相关信息，方便后续分析和优化。

### 7. **总结**

死锁是mysql中常见的并发问题，虽然mysql的InnoDB存储引擎提供了自动检测和处理机制，但频繁的死锁会影响系统的性能和稳定性。因此，理解死锁的原因、掌握预防和处理的方法非常重要。