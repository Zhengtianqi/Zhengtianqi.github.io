---
title: 跳表
author: ztq
tag:
  - 数据库
category:
  - 数据库
date: 2024-12-06 16:52:00
---
跳表（Skip List）是一种数据结构，旨在提供高效的插入、删除和查找操作，同时保持相对简单的实现。它结合了链表和二叉搜索树的优点，通过引入多级索引来加速查找过程。跳表最早由William Pugh在1989年提出，并因其高效性和易于实现而被广泛应用于各种场景，尤其是在分布式系统和内存数据库中。

### 1. **基本概念**

跳表本质上是一个**多层链表**，每一层都是对下一层的“抽样”或“稀疏表示”。最底层（通常称为第0层）包含所有元素，按升序排列。每一层之上的层则只包含一部分元素，形成一个稀疏的索引。随着层数的增加，每一层的元素数量逐渐减少，直到最顶层可能只有少数几个元素。

- **节点**：每个节点包含两个主要信息：
    - **值（Value）**：存储的实际数据。
    - **指针（Pointers）**：指向同一层的下一个节点以及下一层的相同位置的节点。

- **层级**：跳表的高度（即层数）是动态变化的，通常通过随机化的方式决定新插入的节点应该出现在哪些层。最底层（第0层）包含所有节点，而上层的节点数量逐渐减少。

### 2. **工作原理**

#### **查找操作**
- **从最高层开始**：查找时，从跳表的最高层开始，逐层向下查找。每次查找时，沿着当前层的指针向右移动，直到找到一个大于目标值的节点，然后切换到下一层继续查找。
- **逐层深入**：通过这种方式，跳表可以在较高层次快速跳过大量无关的节点，从而加速查找过程。最终，查找会在最底层（第0层）找到目标节点或确定目标值不存在。

#### **插入操作**
- **随机化层数**：当插入一个新节点时，首先确定该节点应该出现在哪些层。通常使用一个随机数生成器来决定新节点的层数，确保较高的层有较少的节点。常见的做法是每层的概率为50%，即新节点有50%的概率出现在上一层。
- **更新指针**：插入节点后，需要更新相关节点的指针，以保持跳表的连贯性。具体来说，需要更新新节点所在层的所有前驱节点的指针，使其指向新节点。

#### **删除操作**
- **移除节点**：删除一个节点时，只需将其从所有出现的层中移除，并更新相关节点的指针。注意，删除操作不会改变跳表的总层数，除非最顶层的所有节点都被删除。

### 3. **性能分析**

跳表的时间复杂度与平衡二叉搜索树类似，但在实际应用中往往表现得更好，尤其是在并发环境下。以下是跳表的主要时间复杂度：

- **查找**：平均时间复杂度为 **O(log n)**，最坏情况下为 **O(n)**（但这种情况非常罕见，尤其是当层数足够多时）。
- **插入**：平均时间复杂度为 **O(log n)**，最坏情况下为 **O(n)**。
- **删除**：平均时间复杂度为 **O(log n)**，最坏情况下为 **O(n)**。

### 4. **优点**

- **高效性**：跳表的查找、插入和删除操作的平均时间复杂度均为 **O(log n)**，接近于平衡二叉搜索树的性能，但实现更加简单。
- **并发友好**：跳表的多层结构使得并发操作更加容易实现。例如，多个线程可以同时在不同层上进行查找或插入操作，而不会相互干扰。
- **动态调整**：跳表的层数是动态变化的，可以根据实际需求自动调整，避免了像平衡树那样频繁的结构调整。
- **易于实现**：相比于红黑树、AVL树等复杂的平衡树结构，跳表的实现更为简单，代码量更少，调试也更容易。

### 5. **缺点**

- **空间开销**：由于每个节点可能存在于多个层中，跳表的空间开销比普通的链表或数组要大。不过，通过合理的随机化策略，可以将空间开销控制在可接受的范围内。
- **最坏情况性能**：虽然跳表的平均性能很好，但在极端情况下（如随机化失败），性能可能会退化为 **O(n)**。不过，这种情况发生的概率非常低。

### 6. **应用场景**

跳表因其高效性和并发友好性，广泛应用于以下场景：

- **内存数据库**：如Redis，Redis使用跳表作为有序集合（Sorted Set）的底层实现之一，用于高效地存储和查询有序数据。
- **分布式系统**：跳表常用于分布式系统的索引结构，特别是在需要高并发读写操作的场景中。
- **缓存系统**：跳表可以用于实现高效的LRU（Least Recently Used）缓存，帮助快速查找和淘汰不常用的数据。
- **日志系统**：跳表可以用于实现高效的日志记录和查询，特别是在需要按时间顺序存储和检索日志的情况下。

### 7. **总结**

跳表是一种高效的、基于链表的索引结构，通过引入多层索引来加速查找、插入和删除操作。它的设计简单且易于实现，特别适合需要高并发读写操作的场景。虽然跳表的空间开销略高于普通链表，但其性能优势和并发友好性使其成为许多应用的理想选择。